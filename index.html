<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HTML Tutorial</title>
</head>
<body>

  <h1>Hi</h1>
  <p>Hello</p>

  <h2>Try</h2>
  <p>
    <a href="https://tannyfolio.pages.dev">
      This is a link I think hehe.
    </a>
  </p>

  <h1>Final</h1>
<h1><strong>server.js</strong></h1>
<code><pre>
require('dotenv').config();
const axios = require('axios');
const fs = require('fs');
const path = require('path');
const { google } = require('googleapis');
const querystring = require('querystring');

// --- üõ°Ô∏è CONFIGURATION ---
const CHECK_INTERVAL_MINUTES = 15;
const TOKEN_PATH = path.join(__dirname, 'zoom_token.json');
const LOG_PATH = path.join(__dirname, 'completed_log.json');
const CLICKUP_LAST_1_1_ID = "a1461481-3edc-4c68-b542-3f24b2386dec";

// üõí SALES EQUATION TEAM
const SALES_TEAM_FOLDERS = {
    "yoshi@ecommerceequation.com.au": "1i-1JcXYriROX05FJ1vq-Si9p885cYdnh",
    "shant@ecommerceequation.com.au": "1HKQN41WjsOay2oQTPLeDlooZRi0jqRsf",
    "jaket@ecommerceequation.com.au": "1UPVHx1DpeooUi6bnoKwNa0tPPXsWDV9M",
    "seanb@ecommerceequation.com.au": "1PQ_Bm3wkVXYMHPSVhoOb1AoQFQ23JwHS"
};

// üö´ BLACKLIST (Emails)
const IGNORE_EMAILS = [
    "jw@jaywright.com.au", "finance@ecommerceequation.com.au", "jake@ecommerceequation.com.au",
    "kelsey@ecommerceequation.com.au", "lisa@ecommerceequation.com.au", "bel@ecommerceequation.com.au",
    "emilie@ecommerceequation.com.au", "carlos@ecommerceequation.com.au", "jiah@ecommerceequation.com.au",
    "arthur@ecommerceequation.com.au", "luiza@ecommerceequation.com.au", "geneca@ecommerceequation.com.au",
    "andres@ecommerceequation.com.au", "will@ecommerceequation.com.au", "michelles@ecommerceequation.com.au",
    "kimberley@ecommerceequation.com.au", "elizabeth@ecommerceequation.com.au", "ella@ecommerceequation.com.au",
    "kieren@ecommerceequation.com.au", "paige@ecommerceequation.com.au", "thelab@ecommerceequation.com.au",
    "kit@ecommerceequation.com.au", "ernie@ecommerceequation.com.au", "reece@ecommerceequation.com.au",
    "zahrah@ecommerceequation.com.au", "esteban@ecommerceequation.com.au", "mia@ecommerceequation.com.au",
    "admin@ecommerceequation.com.au", "norma@ecommerceequation.com.au", "edel@ecommerceequation.com.au",
    "geralde@ecommerceequation.com.au", "linda@ecommerceequation.com.au", "madisongracewhite@gmail.com",
    "noah@ecommerceequation.com.au", "hayden@ecommerceequation.com.au", "jeff@ecommerceequation.com.au",
    "kingsley@ecommerceequation.com.au", "sooji@ecommerceequation.com.au", "brendan@ecommerceequation.com.au",
    "benjamin@ecommerceequation.com.au", "dan@ecommerceequation.com.au", "michelle@ecommerceequation.com.au",
    "kye@ecommerceequation.com.au", "jasmynn@ecommerceequation.com.au", "neil@ecommerceequation.com.au",
    "nigel@ecommerceequation.com.au", "matt@ecommerceequation.com.au", "theodore@ecommerceequation.com.au",
    "chantel@ecommerceequation.com.au", "kate@ecommerceequation.com.au", "ali@ecommerceequation.com.au",
    "joss@ecommerceequation.com.au", "stevie@ecommerceequation.com.au", "johann@ecommerceequation.com.au",
    "jen@ecommerceequation.com.au"
];

const IGNORE_TOPICS = [
    "Ecommerce Equation", "Ecommerce Equation Zoom", "Accelerate Call", "CUSTOMERS Zoom", "Boardroom"
];

// Global Cache
let FIELD_MAP = { internal: null, member: null };
let CLICKUP_CACHE = []; 

// --- HELPER FUNCTIONS ---
function getFormattedDate(dateString) {
    const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    const d = new Date(dateString);
    return `${d.getDate()} ${months[d.getMonth()]} ${d.getFullYear()}`;
}

async function sendEmailNotification(status, videoName, brand, linkOrReason) {
    if (!process.env.EMAIL_USER) return;
    const oauth2Client = new google.auth.OAuth2(process.env.GOOGLE_CLIENT_ID, process.env.GOOGLE_CLIENT_SECRET, "http://localhost:3000/oauth2callback");
    oauth2Client.setCredentials({ refresh_token: process.env.GOOGLE_REFRESH_TOKEN });
    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });
    
    const subject = status === 'SUCCESS' ? `‚úÖ Upload Success: ${videoName}` : `‚ùå Upload Failed: ${videoName}`;
    const text = status === 'SUCCESS' ? `Video: ${videoName}\nBrand: ${brand}\n\nSuccessfully uploaded to Drive!\nView here: ${linkOrReason}` : `Video: ${videoName}\nBrand: ${brand}\n\nFailed to upload.\nReason: ${linkOrReason}`;
    
    const utf8Subject = `=?utf-8?B?${Buffer.from(subject).toString('base64')}?=`;
    const messageParts = [`From: <${process.env.EMAIL_USER}>`, `To: <${process.env.EMAIL_USER}>`, `Subject: ${utf8Subject}`, `MIME-Version: 1.0`, `Content-Type: text/plain; charset=utf-8`, `Content-Transfer-Encoding: 7bit`, ``, text];
    const message = messageParts.join('\n');
    const encodedMessage = Buffer.from(message).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

    try { await gmail.users.messages.send({ userId: 'me', requestBody: { raw: encodedMessage } }); } catch (e) { console.error("   ‚ùå Failed to send email:", e.message); }
}

async function getZoomAccessToken() {
    if (!fs.existsSync(TOKEN_PATH)) throw new Error("‚ùå No Token Found!");
    let tokenData = JSON.parse(fs.readFileSync(TOKEN_PATH));
    if (Date.now() >= tokenData.expires_at) {
        console.log('   üîÑ Refreshing Zoom Token...');
        const credentials = Buffer.from(`${process.env.ZOOM_CLIENT_ID}:${process.env.ZOOM_CLIENT_SECRET}`).toString('base64');
        const res = await axios.post('https://zoom.us/oauth/token', querystring.stringify({ grant_type: 'refresh_token', refresh_token: tokenData.refresh_token }), { headers: { 'Authorization': `Basic ${credentials}`, 'Content-Type': 'application/x-www-form-urlencoded' } });
        tokenData = { access_token: res.data.access_token, refresh_token: res.data.refresh_token, expires_at: Date.now() + (res.data.expires_in * 1000) - 5000 };
        fs.writeFileSync(TOKEN_PATH, JSON.stringify(tokenData));
    }
    return tokenData.access_token;
}

// --- CLICKUP UTILS ---
async function refreshClickUpCache() {
    if (!process.env.CLICKUP_LIST_ID || !process.env.CLICKUP_API_KEY) return;
    if (!FIELD_MAP.internal) {
        const res = await axios.get(`https://api.clickup.com/api/v2/list/${process.env.CLICKUP_LIST_ID}/field`, { headers: { 'Authorization': process.env.CLICKUP_API_KEY } });
        FIELD_MAP.internal = res.data.fields.find(f => f.name === process.env.CLICKUP_INTERNAL_COL_NAME)?.id;
        FIELD_MAP.member = res.data.fields.find(f => f.name === process.env.CLICKUP_MEMBER_COL_NAME)?.id;
    }
    console.log("   üì• Downloading ClickUp Database (Lite Mode)...");
    let allLiteTasks = [], page = 0, keepGoing = true;
    while (keepGoing) {
        try {
            const res = await axios.get(`https://api.clickup.com/api/v2/list/${process.env.CLICKUP_LIST_ID}/task?include_closed=true&subtasks=true&page=${page}`, { headers: { 'Authorization': process.env.CLICKUP_API_KEY } });
            if (!res.data.tasks || res.data.tasks.length === 0) keepGoing = false;
            else {
                allLiteTasks = allLiteTasks.concat(res.data.tasks.map(t => ({ id: t.id, n: t.name.trim().toLowerCase(), i: t.custom_fields.find(f => f.id === FIELD_MAP.internal)?.value, m: t.custom_fields.find(f => f.id === FIELD_MAP.member)?.value })));
                process.stdout.write(`      Page ${page} loaded...\r`);
                page++;
            }
        } catch (e) { keepGoing = false; }
    }
    console.log(`\n   ‚úÖ ClickUp Cache Updated: ${allLiteTasks.length} Brands loaded.`);
    CLICKUP_CACHE = allLiteTasks;
}

function findFolderLinksInMemory(brandName) {
    const task = CLICKUP_CACHE.find(t => t.n === brandName.trim().toLowerCase());
    if (!task) return null;
    const extractId = (link) => { if (!link) return null; if (link.includes('id=')) return link.split('id=')[1]; const parts = link.split('/'); return parts[parts.length - 1] || parts[parts.length - 2]; };
    return { taskId: task.id, internalFolderId: extractId(task.i), memberFolderId: extractId(task.m) };
}

async function updateClickUpLast1on1(taskId, dateUnix) {
    if (!taskId || !CLICKUP_LAST_1_1_ID) return;
    try { await axios.post(`https://api.clickup.com/api/v2/task/${taskId}/field/${CLICKUP_LAST_1_1_ID}`, { value: dateUnix }, { headers: { 'Authorization': process.env.CLICKUP_API_KEY, 'Content-Type': 'application/json' } }); console.log(`      üìÖ ClickUp 'Last 1:1' updated for Task ${taskId}`); } 
    catch (e) { console.error(`      ‚ö†Ô∏è Failed to update ClickUp Date: ${e.message}`); }
}

async function createDriveFolder(folderName, parentId) {
    const oauth2Client = new google.auth.OAuth2(process.env.GOOGLE_CLIENT_ID, process.env.GOOGLE_CLIENT_SECRET, "http://localhost");
    oauth2Client.setCredentials({ refresh_token: process.env.GOOGLE_REFRESH_TOKEN });
    const drive = google.drive({ version: 'v3', auth: oauth2Client });
    // ‚ö†Ô∏è FIXED: Added supportsAllDrives for Shared Drive Access
    const res = await drive.files.create({ 
        resource: { name: folderName, mimeType: 'application/vnd.google-apps.folder', parents: [parentId] }, 
        fields: 'id',
        supportsAllDrives: true 
    });
    return res.data.id;
}

async function uploadToDrive(filePath, fileName, folderId) {
    const oauth2Client = new google.auth.OAuth2(process.env.GOOGLE_CLIENT_ID, process.env.GOOGLE_CLIENT_SECRET, "http://localhost");
    oauth2Client.setCredentials({ refresh_token: process.env.GOOGLE_REFRESH_TOKEN });
    const drive = google.drive({ version: 'v3', auth: oauth2Client });
    // ‚ö†Ô∏è FIXED: Added supportsAllDrives
    const res = await drive.files.create({ 
        resource: { name: fileName, parents: [folderId] }, 
        media: { mimeType: 'video/mp4', body: fs.createReadStream(filePath) }, 
        fields: 'id, webViewLink',
        supportsAllDrives: true
    });
    return res.data;
}

// --- MAIN LOOP ---
async function checkZoom() {
    try {
        console.log(`\nüïí Watchman Scan: ${new Date().toLocaleTimeString()}`);
        await refreshClickUpCache();
        const token = await getZoomAccessToken();
        let completed = [];
        if (fs.existsSync(LOG_PATH)) completed = JSON.parse(fs.readFileSync(LOG_PATH));

        const d = new Date(); const toDate = d.toISOString().split('T')[0];
        d.setDate(d.getDate() - 7); const fromDate = d.toISOString().split('T')[0];

        const usersRes = await axios.get('https://api.zoom.us/v2/users?page_size=300', { headers: { 'Authorization': `Bearer ${token}` } });
        const users = usersRes.data.users || [];

        for (const user of users) {
            if (IGNORE_EMAILS.includes(user.email)) continue;
            try {
                const res = await axios.get(`https://api.zoom.us/v2/users/${user.id}/recordings?from=${fromDate}&to=${toDate}`, { headers: { 'Authorization': `Bearer ${token}` } });
                if (!res.data.meetings) continue;

                for (const meeting of res.data.meetings) {
                    if (completed.includes(meeting.uuid)) continue;
                    
                    let links = null;
                    let brand = "";
                    let isSalesEquation = false;
                    let shouldSkipForever = false;

                    // 1. SALES LOGIC
                    if (SALES_TEAM_FOLDERS[user.email]) {
                        if (!meeting.topic.includes(' x ')) {
                            shouldSkipForever = true; 
                        } else {
                            console.log(`   üöÄ [STEP 1] Found Sales Video: "${meeting.topic}"`);
                            console.log(`      ‚Ü≥ Creating Subfolder in Drive...`);
                            
                            const parentId = SALES_TEAM_FOLDERS[user.email];
                            // If this fails, we catch error below and Retry next loop
                            const subFolderId = await createDriveFolder(meeting.topic, parentId);
                            console.log(`      ‚úÖ [STEP 2] Folder Created! ID: ${subFolderId}`);
                            
                            links = { internalFolderId: subFolderId, memberFolderId: subFolderId };
                            isSalesEquation = true;
                            brand = "Sales Equation";
                        }
                    } 
                    // 2. STANDARD LOGIC
                    else {
                        if (IGNORE_TOPICS.some(ignored => meeting.topic.includes(ignored))) {
                             shouldSkipForever = true;
                        } else {
                            const nameParts = meeting.topic.split(' x ');
                            if (nameParts.length < 2) {
                                shouldSkipForever = true;
                            } else {
                                brand = nameParts[1].split('-')[0].trim();
                                if (nameParts[1].includes("Scale Session")) brand = nameParts[0].trim();
                                console.log(`   üöÄ Found Standard Video: "${meeting.topic}"`);
                                links = findFolderLinksInMemory(brand);
                            }
                        }
                    }

                    if (shouldSkipForever) {
                        completed.push(meeting.uuid);
                        fs.writeFileSync(LOG_PATH, JSON.stringify(completed, null, 2));
                        continue;
                    }

                    if (!links || !links.internalFolderId) {
                        console.log(`      ‚ùå Brand "${brand}" missing details.`);
                        await sendEmailNotification('FAIL', meeting.topic, brand, "Brand not found in ClickUp.");
                        continue;
                    }

                    console.log(`      ‚úÖ [STEP 3] Destination Found! Downloading files...`);

                    let allFilesSuccess = true;
                    const niceDate = getFormattedDate(meeting.start_time);
                    let updatedClickUp = false;

                    for (const file of meeting.recording_files) {
                        if (file.file_type !== 'MP4' && file.file_type !== 'M4A') continue;
                        const fileExt = file.file_type === 'MP4' ? '.mp4' : '.m4a';
                        let finalFileName = `${meeting.topic} - ${niceDate}${fileExt}`.replace(/[:\/]/g, '');
                        const tempPath = path.join(__dirname, finalFileName);

                        try {
                            const writer = fs.createWriteStream(tempPath);
                            const streamRes = await axios({ url: `${file.download_url}?access_token=${token}`, method: 'GET', responseType: 'stream' });
                            streamRes.data.pipe(writer);
                            await new Promise((resolve, reject) => { writer.on('finish', resolve); writer.on('error', reject); });

                            let targetFolder = links.memberFolderId;
                            if (file.file_type === 'MP4') targetFolder = links.internalFolderId;
                            if (user.email === 'travis@ecommerceequation.com.au') targetFolder = links.internalFolderId;

                            console.log(`      üì§ [STEP 4] Uploading "${finalFileName}"...`);
                            const uploadData = await uploadToDrive(tempPath, finalFileName, targetFolder);
                            
                            if (file.file_type === 'MP4') {
                                    await sendEmailNotification('SUCCESS', finalFileName, brand, `https://drive.google.com/file/d/${uploadData.id}/view`);
                                    if (!isSalesEquation && links.taskId && !updatedClickUp) {
                                        await updateClickUpLast1on1(links.taskId, new Date(meeting.start_time).getTime());
                                        updatedClickUp = true;
                                    }
                            }
                            console.log(`      üéâ [STEP 5] Upload Complete!`);
                        } catch (err) {
                            console.error(`      ‚ùå Error Uploading: ${err.message}`);
                            await sendEmailNotification('FAIL', meeting.topic, brand, err.message);
                            allFilesSuccess = false;
                        } finally {
                            if (fs.existsSync(tempPath)) fs.unlinkSync(tempPath); 
                        }
                    }

                    if (allFilesSuccess) {
                        completed.push(meeting.uuid);
                        fs.writeFileSync(LOG_PATH, JSON.stringify(completed, null, 2));
                    } else {
                        console.log("      ‚ö†Ô∏è Upload had errors. Will retry next cycle.");
                    }
                }
            } catch (err) { 
                console.error(`   ‚ùå Critical Error for User ${user.email}: ${err.message}`);
                if (err.response) console.error(err.response.data);
            }
        }
    } catch (error) { console.error("‚ùå Watchman Error:", error.message); }
}

checkZoom();
setInterval(checkZoom, CHECK_INTERVAL_MINUTES * 60 * 1000);
</pre></code>

<h1><strong>get token.js</strong></h1>
<code><pre>
    const { google } = require('googleapis');
const http = require('http');
const url = require('url');
require('dotenv').config();

const oauth2Client = new google.auth.OAuth2(
    process.env.GOOGLE_CLIENT_ID,
    process.env.GOOGLE_CLIENT_SECRET,
    "http://localhost:3000/oauth2callback"
);

// üö® UPDATED SCOPE: NOW 'drive' INSTEAD OF 'drive.file'
const scopes = [
    'https://www.googleapis.com/auth/drive',      // <--- Full Access to see Yoshi's folder
    'https://www.googleapis.com/auth/gmail.send'
];

const server = http.createServer(async (req, res) => {
    if (req.url.startsWith('/oauth2callback')) {
        const qs = new url.URL(req.url, 'http://localhost:3000').searchParams;
        const code = qs.get('code');
        const { tokens } = await oauth2Client.getToken(code);
        
        console.log('\n‚ú® NEW SUPER TOKEN (Copy to .env):');
        console.log('------------------------------------------------');
        console.log(tokens.refresh_token); 
        console.log('------------------------------------------------\n');
        
        res.end('Success! You have the Master Token. Check terminal.');
        server.close();
        process.exit(0);
    }
});

server.listen(3000, () => {
    const authUrl = oauth2Client.generateAuthUrl({
        access_type: 'offline',
        scope: scopes,
        prompt: 'consent'
    });
    console.log(`\nüîó CLICK THIS LINK: ${authUrl}\n`);
});
</pre></code>

</body>
</html>
